set $expire "600";
set $salt "mysalt";


perl_require POSIX.pm;
perl_require Digest/MD5.pm;

perl_set $realurl '
    sub {
        my $secret = "mysalt";
        my $expire = 600;

        my $r = shift;

        if ($r->uri =~ m#^/(\d{4})/(\d{2})/(\d{2})/(\d{2})/(\d{2})/(\d{32})(/\S+\.mp3)#oi) {
            my ($year, $month, $day, $hour, $min, $md5, $path) = 
                ($1, $2, $3, $4, $5, $6, $7);

            my $str = Digest::MD5::md5_hex($secret . $year . $month . $day . $min . $path);

            my $req_time = POSIX::mktime(00, $min, $hour, $day, $month - 1, $year - 1900);
            my $now = time();

            if ($str eq $md5 && $now - $req_time < $expire) {
                return $path;
            } else {
                return "error";
            }
        } else {
            return "error";
    }
}';


location ~* \.mp3$ {
    if ($realurl = "error") {
        return 403;
    }

    proxy_pass http://music_store_local$realurl;
    proxy_set_header Host $host;
}


location ~* \.mp3$ {
    rewrite_by_lua '
        local date = {}

        local md5str

        local path

        date.year, date.month, date.day, date.hour, date.min, md5str, path = string.match(ngx.var.uri, "^/(%d+)/(%d+)/(%d+)/(%d+)/(%d+)/(%w+)(/%S+)")

        if date.year == nil then
            ngx.exit(404)
        end

        local time1 = tonumber(os.time(date))
        local time2 = tonumber(ngx.time())

        if md5str == ngx.md5(ngx.var.salt..date.year..date.month..date.date..date.hour..date.min..path) then
            if time2 - time1 < tonumber(ngx.var.expire) then
                ngx.req.set_uri(path)
            else
                ngx.exit(405)
            end
        else
            ngx.exit(403)
        end
    ';
    proxy_pass http://backend;
    proxy_set_header Host $host;

}



location / {
    set $str $uri;


    init_by_lua '

    ';

    content_by_lua '
        local url = ngx.var.uri
        local res = ngx.location.capture("/proxy", { vars = { str = url }})

        ngx.print(res.body)

        ngx.shared.log_dict:set("url", url)

        local upstream_stat = ngx.var.status
        local upstream_time = tonumber(ngx.var.upstream_response_time)

        local redis = require "resty.redis"

        local red = redis:new()

        local ok, err = red:connect("127.0.0.1", 6379)
        if upstream_stat ~= "200" then
            red:sadd("url", url)
            red:incr(url)
            red:incr(url..":time", upstream_time
        end
    ';
}

location /dict_status {
    content_by_lua '
        local url = ngx.shared.log_dict:get("url")
        ngx.say(url)
    ';
}

location /redis_status {
    content_by_lua '
        local redis = require "resty.redis"
        local red = redis:new()

        local ok, err = red:connect("127.0.0.1", 6379)
        local urlist, err = red:sort("url", "limit", "0", "1", "desc", "by", "*")

        if not urlist then
            ngx.say(err)
            return
        end

        for i = 1, #urlist do
            local avg = red:get(urlist[i])
            local sum = red:get(urlist[i]..":time")
            ngx.say(urlist[i], "\tavg_time:", avg/sum, "\tsum:", sum)
        end
    ';
}



perl_set $time_check '
    sub {
        my $r = shift;

        my $args = $r->args;

        if ($args =~ /t=(\d+)/){
            my $time = $1;
            if(abs(time - time()) < 15) {
                return 0;
            }
        }
        return 1;
    }
';


perl_set $ubuntu '
    sub {
        my $r = shift;
        my $ua = $r->header_in("User-Agent");
        return "1" if $ua =~ m/Ubuntu/xms;
        return "";
    }
';



server {
        listen 80 default_server;
        server_name '';
        access_log  off;
}

#加一个 server 给所有主机名不存的请求放到这个中来处理，并给日志关掉。
